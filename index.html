<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Office Simulator - Local Development</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        #dialogue-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            display: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
        }
        
        #dialogue-box h3 {
            margin: 0 0 10px 0;
            color: #D97356;
        }
        
        #dialogue-content {
            margin: 10px 0;
            line-height: 1.6;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .dialogue-option {
            background: #f0f0f0;
            border: 2px solid #D97356;
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .dialogue-option:hover {
            background: #D97356;
            color: white;
            transform: translateX(5px);
        }
        
        #custom-question-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        #custom-question-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #D97356;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            box-sizing: border-box;
        }
        
        #custom-question-submit {
            background: #D97356;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            margin-top: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        #custom-question-submit:hover {
            background: #c85a3f;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        #custom-question-submit:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(217, 115, 86, 0.3);
            border-radius: 50%;
            border-top-color: #D97356;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .instruction {
            opacity: 0.8;
            font-size: 14px;
            margin-top: 10px;
        }
        
        #interaction-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            font-size: 14px;
        }
        
        .floating-text {
            position: absolute;
            color: #ff0;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 2s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-100px); }
        }

        #dev-notice {
            position: absolute;
            top: 10px;
            right: 20px;
            background: rgba(0, 255, 0, 0.1);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #00ff00;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="dev-notice">
        LOCAL DEV MODE<br>
        Ready for Claude Code!
    </div>
    
    <div id="ui-overlay">
        <h2 id="title">3D Office Simulator</h2>
        <p style="font-size: 20px;" id="subtitle">üß† Interactive Environment</p>
        <p id="move-instruction">Use WASD to move around</p>
        <p id="look-instruction">Arrow keys or mouse to look left/right</p>
        <p id="interact-instruction">Press E to interact</p>
        <p id="dance-instruction">Press SPACE to dance</p>
        <p id="close-instruction">Press ESC to close dialogs/release mouse</p>
        <p id="ball-instruction">Walk into the red ball to kick it</p>
        <p id="throw-instruction">Click on the ball to throw it</p>
        <p class="instruction" style="margin-top: 10px;" id="tip-instruction">üí° Type custom questions when talking!</p>
    </div>
    
    <div id="dialogue-box">
        <h3 id="dialogue-name">Character Name</h3>
        <div id="dialogue-content">Dialogue content will appear here</div>
        <div id="dialogue-options"></div>
        <div id="custom-question-container">
            <p style="margin: 5px 0; font-size: 14px; opacity: 0.8; text-align: center;" id="custom-question-divider">‚îÅ‚îÅ‚îÅ Or ask your own question ‚îÅ‚îÅ‚îÅ</p>
            <input type="text" id="custom-question-input" placeholder="Ask anything! e.g., 'What's your favorite feature?' or 'Tell me about your work'" maxlength="200">
            <button id="custom-question-submit">Ask Question</button>
        </div>
    </div>
    
    <div id="interaction-prompt"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        console.log('üöÄ 3D Office Simulator - Local Development Mode');
        console.log('Ready for customization with Claude Code!');
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);
        scene.fog = new THREE.Fog(0xf5f5f5, 10, 50);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Floating text effect
        function createFloatingText(text, worldPos) {
            const screenPos = worldPos.clone();
            screenPos.project(camera);
            
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
            
            const div = document.createElement('div');
            div.className = 'floating-text';
            div.textContent = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.body.appendChild(div);
            
            setTimeout(() => div.remove(), 2000);
        }
        
        // Enhanced Lighting System
        const ambientLight = new THREE.AmbientLight(0xf0f8ff, 0.4);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Accent lighting
        const accentLight1 = new THREE.PointLight(0x00ff88, 0.6, 15);
        accentLight1.position.set(-15, 8, -15);
        scene.add(accentLight1);
        
        const accentLight2 = new THREE.PointLight(0xff4488, 0.6, 15);
        accentLight2.position.set(15, 8, -15);
        scene.add(accentLight2);
        
        const accentLight3 = new THREE.PointLight(0x4488ff, 0.6, 15);
        accentLight3.position.set(0, 8, 15);
        scene.add(accentLight3);
        
        // Ceiling mood lighting (subtle color changing)
        const moodLight = new THREE.PointLight(0x6366f1, 0.3, 25);
        moodLight.position.set(0, 12, 0);
        scene.add(moodLight);
        
        // Animate mood lighting
        let lightTime = 0;
        function animateLighting() {
            lightTime += 0.01;
            const hue = (Math.sin(lightTime) + 1) * 0.5;
            moodLight.color.setHSL(hue * 0.6 + 0.6, 0.5, 0.3);
        }
        
        // Floor with pattern
        const floorGeometry = new THREE.PlaneGeometry(40, 40);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xdcdcdc,
            roughness: 0.7,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Add floor tiles pattern
        const tileGeometry = new THREE.PlaneGeometry(2, 2);
        const tileMaterial1 = new THREE.MeshStandardMaterial({ color: 0xe8e8e8 });
        const tileMaterial2 = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });
        
        for (let x = -20; x < 20; x += 2) {
            for (let z = -20; z < 20; z += 2) {
                const tile = new THREE.Mesh(tileGeometry, ((x + z) / 2) % 2 === 0 ? tileMaterial1 : tileMaterial2);
                tile.position.set(x + 1, 0.01, z + 1);
                tile.rotation.x = -Math.PI / 2;
                tile.receiveShadow = true;
                scene.add(tile);
            }
        }
        
        // Walls with windows
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xf8f8f8,
            roughness: 0.9
        });
        
        const windowMaterial = new THREE.MeshStandardMaterial({
            color: 0x87ceeb,
            transparent: true,
            opacity: 0.3,
            roughness: 0.1,
            metalness: 0.5
        });
        
        // Back wall with windows - make it more visible
        const backWallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xe5e7eb,  // Light gray
            roughness: 0.8,
            metalness: 0.1
        });
        const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            backWallMaterial
        );
        backWall.position.set(0, 5, -19.9);
        backWall.receiveShadow = true;
        scene.add(backWall);
        console.log('Back wall created and added to scene at:', backWall.position);
        console.log('Back wall material:', backWallMaterial);
        
        // Add windows to back wall
        for (let x = -15; x <= 15; x += 10) {
            const window = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 3),
                windowMaterial
            );
            window.position.set(x, 5, -19.9);
            scene.add(window);
        }
        
        // Side walls
        const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        leftWall.position.set(-20, 5, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        scene.add(leftWall);
        
        const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        rightWall.position.set(20, 5, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        scene.add(rightWall);
        
        // Front wall (was missing!)
        const frontWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        frontWall.position.set(0, 5, 20);
        frontWall.rotation.y = Math.PI; // Face inward
        frontWall.receiveShadow = true;
        scene.add(frontWall);
        console.log('Front wall created and added to scene at:', frontWall.position);
        
        // ========================================================================
        // SIMPLE ART GALLERY - Front Wall
        // No textures to avoid WebGL limits - just colored geometry
        // ========================================================================
        
        // Gallery configuration - your 3 artworks
        const artworks = [
            { 
                title: "Escher Vision", 
                image: "./images/gallery/A_highly_detailed,_Escher-inspired_painting_depict.jpg",
                fallbackColor: 0x4f46e5,
                frame: 0x2d3748 
            },
            { 
                title: "Renaissance Drawing", 
                image: "./images/gallery/A_highly_detailed,_Renaissance-style_ink_drawing_o.jpg",
                fallbackColor: 0x059669,
                frame: 0x8b4513 
            },
            { 
                title: "Realistic Oil", 
                image: "./images/gallery/A_imaginative,_realistic-style_oil_painting_depict.jpg",
                fallbackColor: 0xdc2626,
                frame: 0xffffff 
            }
        ];
        
        // Create gallery frames on front wall
        console.log('Creating simple gallery on front wall...');
        console.log('Available artworks:', artworks);
        
        // Test image accessibility
        artworks.forEach((artwork, index) => {
            const testImg = new Image();
            testImg.onload = () => console.log(`‚úÖ Image accessible: ${artwork.title}`);
            testImg.onerror = () => console.log(`‚ùå Image NOT accessible: ${artwork.title} at ${artwork.image}`);
            testImg.src = artwork.image;
        });
        artworks.forEach((artwork, index) => {
            const frameGroup = new THREE.Group();
            
            // Frame dimensions
            const frameWidth = 2.5;
            const frameHeight = 2;
            const frameDepth = 0.1;
            const frameBorder = 0.15;
            
            // Frame border
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: artwork.frame,
                roughness: 0.4,
                metalness: 0.2
            });
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, frameHeight, frameDepth),
                frameMaterial
            );
            frameGroup.add(frame);
            
            // Create immediate fallback artwork (shows instantly) - BRIGHT color for testing
            const testColors = [0xff0000, 0x00ff00, 0x0000ff]; // Red, Green, Blue - highly visible
            const initialMaterial = new THREE.MeshBasicMaterial({ 
                color: testColors[index] || artwork.fallbackColor,
                side: THREE.DoubleSide
            });
            const art = new THREE.Mesh(
                new THREE.PlaneGeometry(frameWidth - (frameBorder * 2), frameHeight - (frameBorder * 2)),
                initialMaterial
            );
            art.position.set(0, 0, frameDepth / 2 + 0.05); // More forward to ensure visibility
            frameGroup.add(art);
            
            console.log(`üñºÔ∏è Created artwork plane for ${artwork.title} at position:`, art.position);
            console.log(`üé® Initial material color: 0x${testColors[index].toString(16).padStart(6, '0')} (should be ${index === 0 ? 'RED' : index === 1 ? 'GREEN' : 'BLUE'})`);
            
            // Attempt to load actual image (will replace fallback if successful)
            console.log(`üé® Loading artwork: ${artwork.title} from ${artwork.image}`);
            
            const loader = new THREE.TextureLoader();
            loader.load(
                artwork.image, 
                (texture) => {
                    console.log(`‚úÖ Successfully loaded ${artwork.title}!`);
                    console.log(`üìê Original texture size: ${texture.image.width}x${texture.image.height}`);
                    
                    // Check WebGL texture size limits and capabilities
                    const maxSize = renderer.capabilities.maxTextureSize;
                    const maxTextures = renderer.capabilities.maxTextures;
                    const maxTextureImageUnits = renderer.capabilities.maxTextureImageUnits;
                    console.log(`üîß WebGL max texture size: ${maxSize}`);
                    console.log(`üîß WebGL max textures: ${maxTextures}`);
                    console.log(`üîß WebGL max texture image units: ${maxTextureImageUnits}`);
                    
                    // Check if image dimensions are power of 2 (important for WebGL)
                    const isPowerOf2 = (value) => (value & (value - 1)) === 0;
                    const widthPow2 = isPowerOf2(texture.image.width);
                    const heightPow2 = isPowerOf2(texture.image.height);
                    console.log(`üîß Texture power of 2? Width: ${widthPow2}, Height: ${heightPow2}`);
                    
                    // WebGL texture configuration for non-power-of-2 textures
                    texture.flipY = false;
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    
                    // Critical: For non-power-of-2 textures, must use specific filters
                    if (!widthPow2 || !heightPow2) {
                        console.log(`üîß Non-power-of-2 texture detected, using compatible settings`);
                        texture.minFilter = THREE.LinearFilter;  // Cannot use mipmaps
                        texture.magFilter = THREE.LinearFilter;
                        texture.generateMipmaps = false;
                        texture.wrapS = THREE.ClampToEdgeWrapping;
                        texture.wrapT = THREE.ClampToEdgeWrapping;
                    } else {
                        texture.minFilter = THREE.LinearMipmapLinearFilter;
                        texture.magFilter = THREE.LinearFilter;
                        texture.generateMipmaps = true;
                    }
                    
                    // Force texture update
                    texture.needsUpdate = true;
                    
                    // KEEP the bright test color - don't replace material yet
                    console.log(`üö´ SKIPPING material replacement to test if this is the issue`);
                    console.log(`üé® Texture loaded but keeping bright ${index === 0 ? 'RED' : index === 1 ? 'GREEN' : 'BLUE'} color for debugging`);
                    
                    // Force geometry and material update
                    art.geometry.computeBoundingBox();
                    art.material.needsUpdate = true;
                    art.geometry.uvsNeedUpdate = true;
                    
                    // Check if material is properly assigned
                    console.log(`üîç Material check - has map: ${!!newMaterial.map}, texture loaded: ${!!texture.image}`);
                    console.log(`üîç Geometry check - UV coordinates:`, art.geometry.attributes.uv);
                    
                    console.log(`üñºÔ∏è ${artwork.title} texture applied successfully!`);
                    console.log(`üéØ Material updated:`, art.material);
                }, 
                (progress) => {
                    if (progress.total > 0) {
                        console.log(`üì• Loading ${artwork.title}: ${Math.round((progress.loaded / progress.total) * 100)}%`);
                    }
                },
                (error) => {
                    console.error(`‚ùå Failed to load ${artwork.title}:`, error);
                    console.log(`üîÑ Keeping fallback color for ${artwork.title}`);
                    // Art already has fallback color, so nothing more to do
                }
            );
            
            // Position frames horizontally across front wall
            const spacing = 4;
            const startX = -(artworks.length - 1) * spacing / 2;
            
            frameGroup.position.set(
                startX + (index * spacing), // X: spread horizontally  
                5, // Y: eye level
                19.8 // Z: on front wall (slightly inset)
            );
            
            // Add simple gallery lighting
            const spotlight = new THREE.SpotLight(0xffffff, 0.8, 10, Math.PI / 8, 0.3);
            spotlight.position.set(startX + (index * spacing), 7, 17);
            spotlight.target.position.set(startX + (index * spacing), 5, 19.8);
            spotlight.castShadow = false; // Avoid shadow complexity
            
            scene.add(frameGroup);
            scene.add(spotlight);
            scene.add(spotlight.target);
            
            console.log(`Gallery frame ${index + 1} created: ${artwork.title} at X: ${startX + (index * spacing)}`);
        });
        
        // Office furniture materials
        const woodMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b6914,
            roughness: 0.6,
            metalness: 0.1
        });
        
        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0x404040,
            roughness: 0.3,
            metalness: 0.8
        });
        
        // Create detailed desks
        function createDesk(x, z) {
            const deskGroup = new THREE.Group();
            
            // Desk top
            const deskTop = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 1.5),
                woodMaterial
            );
            deskTop.position.y = 0.75;
            deskTop.castShadow = true;
            deskTop.receiveShadow = true;
            deskGroup.add(deskTop);
            
            // Metal frame
            const frameGeometry = new THREE.BoxGeometry(0.05, 0.7, 0.05);
            const framePositions = [
                [-1.45, 0.35, -0.7],
                [1.45, 0.35, -0.7],
                [-1.45, 0.35, 0.7],
                [1.45, 0.35, 0.7]
            ];
            
            framePositions.forEach(pos => {
                const frame = new THREE.Mesh(frameGeometry, metalMaterial);
                frame.position.set(...pos);
                frame.castShadow = true;
                deskGroup.add(frame);
            });
            
            // Computer monitor
            const monitorBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16),
                metalMaterial
            );
            monitorBase.position.set(0, 0.82, 0);
            deskGroup.add(monitorBase);
            
            const monitorStand = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.3, 0.05),
                metalMaterial
            );
            monitorStand.position.set(0, 0.95, 0);
            deskGroup.add(monitorStand);
            
            const monitorScreen = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.7, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.5 })
            );
            monitorScreen.position.set(0, 1.3, 0);
            deskGroup.add(monitorScreen);
            
            // Keyboard
            const keyboard = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.02, 0.15),
                metalMaterial
            );
            keyboard.position.set(0, 0.81, 0.3);
            deskGroup.add(keyboard);
            
            // Chair
            const chairSeat = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.05, 0.5),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairSeat.position.set(0, 0.5, 0.8);
            deskGroup.add(chairSeat);
            
            const chairBack = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.6, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairBack.position.set(0, 0.8, 1.02);
            deskGroup.add(chairBack);
            
            // Random desk items
            if (Math.random() > 0.5) {
                const mug = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 0.1, 8),
                    new THREE.MeshStandardMaterial({ color: 0xffffff })
                );
                mug.position.set(Math.random() * 0.5 - 0.25, 0.85, Math.random() * 0.3);
                deskGroup.add(mug);
            }
            
            // Desk lamp
            const lampBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.05, 8),
                metalMaterial
            );
            lampBase.position.set(-1, 0.82, -0.3);
            deskGroup.add(lampBase);
            
            const lampArm = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.8, 8),
                metalMaterial
            );
            lampArm.position.set(-1, 1.2, -0.3);
            lampArm.rotation.z = Math.PI / 6;
            deskGroup.add(lampArm);
            
            const lampHead = new THREE.Mesh(
                new THREE.ConeGeometry(0.2, 0.3, 8),
                metalMaterial
            );
            lampHead.position.set(-0.7, 1.5, -0.3);
            lampHead.rotation.z = -Math.PI / 3;
            deskGroup.add(lampHead);
            
            // Lamp light
            const lampLight = new THREE.PointLight(0xffd700, 0.8, 5);
            lampLight.position.set(-0.6, 1.4, -0.3);
            lampLight.castShadow = true;
            deskGroup.add(lampLight);
            
            deskGroup.position.set(x, 0, z);
            return deskGroup;
        }
        
        // Add desks
        const desk1 = createDesk(-10, -10);
        const desk2 = createDesk(0, -10);
        const desk3 = createDesk(10, -10);
        const desk4 = createDesk(-10, 5);
        const desk5 = createDesk(0, 5);
        const desk6 = createDesk(10, 5);
        scene.add(desk1, desk2, desk3, desk4, desk5, desk6);
        
        // Add whiteboard
        const whiteboardMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffffff,
            roughness: 0.2,
            metalness: 0.1
        });
        
        const whiteboard = new THREE.Mesh(
            new THREE.BoxGeometry(4, 2, 0.1),
            whiteboardMaterial
        );
        whiteboard.position.set(0, 3, -19.8);
        whiteboard.castShadow = true;
        scene.add(whiteboard);
        
        // Company Logo on back wall
        function createTextTexture(text, bgColor, textColor, fontSize = 48) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            context.fillStyle = bgColor;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = textColor;
            context.font = `bold ${fontSize}px Arial`;
            context.textAlign = 'center';
            context.fillText(text, canvas.width / 2, canvas.height / 2 + fontSize / 4);
            
            return new THREE.CanvasTexture(canvas);
        }
        
        const logoTexture = createTextTexture('TECH SOLUTIONS', '#1e3a8a', '#ffffff', 36);
        const logoMaterial = new THREE.MeshStandardMaterial({ map: logoTexture });
        const logo = new THREE.Mesh(
            new THREE.PlaneGeometry(6, 3),
            logoMaterial
        );
        logo.position.set(0, 6, -19.7);
        scene.add(logo);
        
        // Motivational Posters
        const posterMessages = [
            { text: 'CODE\nCREATE\nINNOVATE', color: '#e11d48' },
            { text: 'THINK\nDIFFERENT', color: '#059669' },
            { text: 'FAIL FAST\nLEARN FASTER', color: '#7c3aed' },
            { text: 'DEPLOY\nON FRIDAY', color: '#dc2626' }
        ];
        
        // Left wall posters
        posterMessages.slice(0, 2).forEach((poster, index) => {
            const posterTexture = createTextTexture(poster.text, '#f8fafc', poster.color, 28);
            const posterMaterial = new THREE.MeshStandardMaterial({ map: posterTexture });
            const posterMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(2.5, 3),
                posterMaterial
            );
            posterMesh.position.set(-19.7, 4 + (index * 3), -8 + (index * 8));
            posterMesh.rotation.y = Math.PI / 2;
            scene.add(posterMesh);
        });
        
        // Right wall posters
        posterMessages.slice(2).forEach((poster, index) => {
            const posterTexture = createTextTexture(poster.text, '#f8fafc', poster.color, 28);
            const posterMaterial = new THREE.MeshStandardMaterial({ map: posterTexture });
            const posterMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(2.5, 3),
                posterMaterial
            );
            posterMesh.position.set(19.7, 4 + (index * 3), -8 + (index * 8));
            posterMesh.rotation.y = -Math.PI / 2;
            scene.add(posterMesh);
        });
        
        // Digital Screens with Content
        function createDigitalScreen(x, y, z, rotation = 0) {
            const screenGroup = new THREE.Group();
            
            // Screen frame
            const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(3.2, 2.2, 0.1),
                frameMaterial
            );
            screenGroup.add(frame);
            
            // Screen content (will animate)
            const screenCanvas = document.createElement('canvas');
            screenCanvas.width = 512;
            screenCanvas.height = 256;
            const screenContext = screenCanvas.getContext('2d');
            
            // Initial screen content
            function updateScreen() {
                const now = Date.now();
                const time = new Date().toLocaleTimeString();
                
                screenContext.fillStyle = '#0f172a';
                screenContext.fillRect(0, 0, 512, 256);
                
                screenContext.fillStyle = '#06b6d4';
                screenContext.font = 'bold 24px Arial';
                screenContext.textAlign = 'center';
                screenContext.fillText('SYSTEM STATUS', 256, 40);
                
                screenContext.fillStyle = '#10b981';
                screenContext.font = '18px Arial';
                screenContext.fillText('‚úì All Systems Online', 256, 80);
                screenContext.fillText('‚úì Deployment Ready', 256, 110);
                screenContext.fillText('‚úì Tests Passing', 256, 140);
                
                screenContext.fillStyle = '#06b6d4';
                screenContext.font = '16px Arial';
                screenContext.fillText(time, 256, 180);
                
                screenContext.fillStyle = '#8b5cf6';
                screenContext.fillText(`Uptime: ${Math.floor(now/1000/60)} min`, 256, 210);
            }
            
            updateScreen();
            const screenTexture = new THREE.CanvasTexture(screenCanvas);
            
            const screen = new THREE.Mesh(
                new THREE.PlaneGeometry(3, 2),
                new THREE.MeshStandardMaterial({ 
                    map: screenTexture,
                    emissive: 0x111111
                })
            );
            screen.position.z = 0.06;
            screenGroup.add(screen);
            
            // Update screen content periodically
            setInterval(() => {
                updateScreen();
                screenTexture.needsUpdate = true;
            }, 1000);
            
            screenGroup.position.set(x, y, z);
            screenGroup.rotation.y = rotation;
            return screenGroup;
        }
        
        // Add digital screens
        const screen1 = createDigitalScreen(-15, 4, -19.8);
        const screen2 = createDigitalScreen(15, 4, -19.8);
        scene.add(screen1, screen2);
        
        // Neon accent elements with proper text
        function createNeonSign(text, x, y, z, color) {
            const neonGroup = new THREE.Group();
            
            // Background panel
            const panel = new THREE.Mesh(
                new THREE.PlaneGeometry(text.length * 0.6, 1.2),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    transparent: true,
                    opacity: 0.8
                })
            );
            neonGroup.add(panel);
            
            // Create text texture using the existing createTextTexture function
            const colorHex = '#' + color.toString(16).padStart(6, '0');
            console.log('Creating neon text:', text, 'with color:', colorHex);
            const textTexture = createTextTexture(text, '#1a1a1a', colorHex, 48);
            const textMaterial = new THREE.MeshStandardMaterial({ 
                map: textTexture,
                emissive: color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.9
            });
            
            // Text plane
            const textMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(text.length * 0.5, 0.8),
                textMaterial
            );
            textMesh.position.z = 0.01;
            neonGroup.add(textMesh);
            
            // Glow light - reduced intensity so it doesn't overwhelm text
            const glowLight = new THREE.PointLight(color, 0.5, 8);
            glowLight.position.z = 2; // Move further back
            neonGroup.add(glowLight);
            
            neonGroup.position.set(x, y, z);
            return neonGroup;
        }
        
        // Add neon signs - Fixed positioning on actual walls
        // EXIT sign on right wall (x=20), slightly inset and visible from inside room
        console.log('Creating EXIT sign...');
        const neonExit = createNeonSign('EXIT', 19.8, 6, 0, 0x00ff00);
        neonExit.rotation.y = -Math.PI / 2; // Face inward toward room center
        scene.add(neonExit);
        console.log('EXIT sign created and added to scene at:', neonExit.position);
        
        // CAFE sign on left wall (x=-20), slightly inset and visible from inside room  
        console.log('Creating CAFE sign...');
        const neonCafe = createNeonSign('CAFE', -19.8, 4, 8, 0xff0080);
        neonCafe.rotation.y = Math.PI / 2; // Face inward toward room center
        scene.add(neonCafe);
        console.log('CAFE sign created and added to scene at:', neonCafe.position);
        console.log('CAFE sign should be PINK/MAGENTA, not green!');
        
        // Interactive Bouncing Ball
        const ballGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const ballMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xff4444,
            roughness: 0.4,
            metalness: 0.1,
            transparent: true,
            opacity: 0.9,
            emissive: 0x331111,
            emissiveIntensity: 0.2
        });
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(5, 2, 5); // Start higher for bouncing
        ball.castShadow = true;
        ball.receiveShadow = true;
        
        // Add glow effect
        const ballGlow = new THREE.PointLight(0xff4444, 0.5, 5);
        ball.add(ballGlow);
        
        // Physics properties
        ball.userData = {
            velocity: new THREE.Vector3(0.1, 0, 0.08),
            gravity: -0.015,
            bounce: 0.8, // Energy retained after bounce
            friction: 0.98, // Air/ground friction
            radius: 0.3,
            isGrounded: false,
            recentlyKicked: false, // Prevent spam kicking
            kickCooldown: 0
        };
        scene.add(ball);
        
        // Plant decorations
        const plantPot = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.25, 0.4, 8),
            new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        plantPot.position.set(-15, 0.2, -15);
        scene.add(plantPot);
        
        const plantLeaves = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 6, 5),
            new THREE.MeshStandardMaterial({ color: 0x228b22 })
        );
        plantLeaves.position.set(-15, 0.8, -15);
        scene.add(plantLeaves);
        
        // Add more plants
        const plantPot2 = plantPot.clone();
        plantPot2.position.set(15, 0.2, -15);
        scene.add(plantPot2);
        
        const plantLeaves2 = plantLeaves.clone();
        plantLeaves2.position.set(15, 0.8, -15);
        scene.add(plantLeaves2);
        
        const plantPot3 = plantPot.clone();
        plantPot3.position.set(0, 0.2, 15);
        scene.add(plantPot3);
        
        const plantLeaves3 = plantLeaves.clone();
        plantLeaves3.position.set(0, 0.8, 15);
        scene.add(plantLeaves3);
        
        // Add coffee station
        const coffeeTable = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.8, 1),
            woodMaterial
        );
        coffeeTable.position.set(-18, 0.4, 10);
        coffeeTable.castShadow = true;
        scene.add(coffeeTable);
        
        const coffeeMachine = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 0.5, 0.3),
            metalMaterial
        );
        coffeeMachine.position.set(-18, 1.05, 10);
        scene.add(coffeeMachine);
        
        // Character creation
        const characters = [];
        
        function createCharacter(name, role, x, z, shirtColor, characterData) {
            const group = new THREE.Group();
            
            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.8, 8);
            const torsoMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.y = 0.6;
            torso.castShadow = true;
            group.add(torso);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6);
            const armMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.3, 0.7, 0);
            leftArm.rotation.z = Math.PI / 8;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.3, 0.7, 0);
            rightArm.rotation.z = -Math.PI / 8;
            group.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.4, 0);
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.4, 0);
            group.add(rightLeg);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 8, 6);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.25;
            head.castShadow = true;
            group.add(head);
            
            // Hair
            const hairGeometry = new THREE.SphereGeometry(0.27, 8, 6);
            const hairMaterial = new THREE.MeshStandardMaterial({ color: characterData.hairColor });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.35;
            hair.scale.y = 0.6;
            group.add(hair);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.03, 4, 4);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.25, 0.22);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.25, 0.22);
            group.add(rightEye);
            
            // Name label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillRect(0, 0, 256, 64);
            context.fillStyle = 'black';
            context.font = 'bold 20px Arial';
            context.textAlign = 'center';
            context.fillText(name, 128, 25);
            context.font = '16px Arial';
            context.fillStyle = '#666';
            context.fillText(role, 128, 45);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.y = 1.8;
            label.scale.set(2, 0.5, 1);
            group.add(label);
            
            group.position.set(x, 0, z);
            group.userData = { 
                name, 
                role, 
                conversations: [],
                initialPosition: new THREE.Vector3(x, 0, z),
                targetPosition: new THREE.Vector3(x, 0, z),
                moveTimer: 0,
                isDancing: false,
                tripChance: 0.001,
                leftArm: leftArm,
                rightArm: rightArm,
                ...characterData
            };
            
            characters.push(group);
            return group;
        }
        
        // Add custom characters
        const character1 = createCharacter('Meaty', 'Lead Developer', -10, -5, 0x4169e1, {
            hairColor: 0x3d3d3d,
            personality: 'laid-back and practical',
            quirk: 'loves to talk about food and coding'
        });
        
        const character2 = createCharacter('Scouse', 'UX Designer', 10, -5, 0x9370db, {
            hairColor: 0x4b0082,
            personality: 'witty and street-smart',
            quirk: 'speaks with Liverpool accent and football metaphors'
        });
        
        const character3 = createCharacter('Simon', 'Data Scientist', -10, 5, 0x228b22, {
            hairColor: 0x8b4513,
            personality: 'analytical and methodical',
            quirk: 'loves statistics and dry humor'
        });
        
        const character4 = createCharacter('Tick', 'Music Producer', 10, 5, 0xffa500, {
            hairColor: 0x8b4513,
            personality: 'energetic and rhythm-obsessed',
            quirk: 'constantly moving to invisible beats and loves techno'
        });
        
        scene.add(character1, character2, character3, character4);
        
        // Player controls
        const player = {
            position: new THREE.Vector3(0, 1.6, 5),
            velocity: new THREE.Vector3(0, 0, 0),
            speed: 0.1,
            isDancing: false
        };
        
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            const customQuestionInput = document.getElementById('custom-question-input');
            
            if (document.activeElement === customQuestionInput) {
                if (e.key === 'Escape') {
                    dialogueBox.style.display = 'none';
                    currentCharacter = null;
                    if (document.pointerLockElement === renderer.domElement) {
                        document.exitPointerLock();
                    }
                }
                return;
            }
            
            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
            
            if (e.key.toLowerCase() === 'e' && nearbyCharacter && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                openDialogue(nearbyCharacter);
            }
            
            if (e.key === ' ' && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                player.isDancing = true;
                createFloatingText('üíÉüï∫', player.position);
            }
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const customQuestionInput = document.getElementById('custom-question-input');
            
            if (document.activeElement === customQuestionInput) {
                return;
            }
            
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
            
            if (e.key === ' ' && dialogueBox.style.display !== 'block') {
                player.isDancing = false;
            }
        });
        
        // Character movement AI
        function updateCharacterMovement(character, deltaTime) {
            if (Math.random() < character.userData.tripChance && !character.userData.isDancing) {
                character.rotation.x = Math.PI / 4;
                character.position.y = 0.3;
                createFloatingText('Oof!', character.position);
                
                setTimeout(() => {
                    character.userData.tripChance = 0.001;
                }, 5000);
            }
            
            if (character === currentCharacter || character.userData.isDancing) {
                if (character === currentCharacter) {
                    const lookTarget = new THREE.Vector3(player.position.x, character.position.y, player.position.z);
                    character.lookAt(lookTarget);
                    character.rotation.x = 0;
                    character.rotation.z = 0;
                }
                return;
            }
            
            if (Math.random() < 0.001) {
                character.userData.isDancing = true;
                createFloatingText('üéµ', character.position);
                setTimeout(() => {
                    character.userData.isDancing = false;
                }, 3000);
            }
            
            character.userData.moveTimer -= deltaTime;
            
            if (character.userData.moveTimer <= 0) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 3 + Math.random() * 5;
                character.userData.targetPosition = new THREE.Vector3(
                    character.userData.initialPosition.x + Math.cos(angle) * distance,
                    0,
                    character.userData.initialPosition.z + Math.sin(angle) * distance
                );
                
                character.userData.targetPosition.x = Math.max(-18, Math.min(18, character.userData.targetPosition.x));
                character.userData.targetPosition.z = Math.max(-18, Math.min(18, character.userData.targetPosition.z));
                
                character.userData.moveTimer = 5 + Math.random() * 5;
            }
            
            const direction = new THREE.Vector3().subVectors(character.userData.targetPosition, character.position);
            direction.y = 0;
            const distance = direction.length();
            
            if (distance > 0.1) {
                direction.normalize();
                character.position.add(direction.multiplyScalar(0.02));
                
                character.lookAt(character.userData.targetPosition);
                character.rotation.x = 0;
                character.rotation.z = 0;
                
                if (!character.userData.isDancing) {
                    character.position.y = Math.abs(Math.sin(Date.now() * 0.005)) * 0.05;
                }
            }
        }
        
        // Dialogue system
        const dialogueBox = document.getElementById('dialogue-box');
        const dialogueName = document.getElementById('dialogue-name');
        const dialogueContent = document.getElementById('dialogue-content');
        const dialogueOptions = document.getElementById('dialogue-options');
        const interactionPrompt = document.getElementById('interaction-prompt');
        
        let currentCharacter = null;
        let nearbyCharacter = null;
        
        function generateDialogueOptions(character) {
            const questions = [
                "Tell me about your role here",
                "What's a typical day like for you?",
                "What's the most challenging part of your job?",
                "What project are you most excited about?",
                "What's your favorite development tool?",
                "Any advice for someone starting out?",
                "What's the weirdest bug you've encountered?",
                "Coffee or tea?",
                "Tabs or spaces?",
                "What's your git commit style?"
            ];
            
            const shuffled = questions.sort(() => Math.random() - 0.5);
            return shuffled.slice(0, 4);
        }
        
        function openDialogue(character) {
            currentCharacter = character;
            dialogueBox.style.display = 'block';
            dialogueName.textContent = `${character.userData.name} - ${character.userData.role}`;
            
            if (document.pointerLockElement === renderer.domElement) {
                document.exitPointerLock();
            }
            
            const greetings = [
                `Hello! I'm ${character.userData.name}, ${character.userData.role}. Ask me anything!`,
                `Hey there! I'm ${character.userData.name}. Just ${character.userData.quirk}, as usual.`,
                `Hi! ${character.userData.name} here. What can I help you understand about our work?`,
                `Great to meet you! I'm ${character.userData.name}. Fair warning: I ${character.userData.quirk}.`
            ];
            
            if (character.userData.conversations.length === 0) {
                dialogueContent.innerHTML = `<p><strong>${character.userData.name}:</strong> ${greetings[Math.floor(Math.random() * greetings.length)]}</p>`;
            } else {
                const lastConv = character.userData.conversations[character.userData.conversations.length - 1];
                dialogueContent.innerHTML = `<p><strong>You:</strong> ${lastConv.user}</p><p><strong>${character.userData.name}:</strong> ${lastConv.response}</p>`;
            }
            
            const options = generateDialogueOptions(character);
            dialogueOptions.innerHTML = '';
            
            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'dialogue-option';
                optionDiv.textContent = option;
                optionDiv.onclick = () => selectOption(option);
                dialogueOptions.appendChild(optionDiv);
            });
            
            document.getElementById('custom-question-input').value = '';
            
            setTimeout(() => {
                document.getElementById('custom-question-input').focus();
            }, 100);
        }
        
        function selectOption(option) {
            if (!currentCharacter) return;
            
            dialogueContent.innerHTML += `<p><strong>You:</strong> ${option}</p>`;
            dialogueContent.innerHTML += `<p><strong>${currentCharacter.userData.name}:</strong> <span class="loading"></span></p>`;
            
            dialogueContent.scrollTop = dialogueContent.scrollHeight;
            
            const customQuestionInput = document.getElementById('custom-question-input');
            const customQuestionSubmit = document.getElementById('custom-question-submit');
            
            dialogueOptions.style.pointerEvents = 'none';
            dialogueOptions.style.opacity = '0.5';
            customQuestionInput.disabled = true;
            customQuestionSubmit.disabled = true;
            
            // Simple fallback responses (replace with your AI integration)
            let responseText = generateFallbackResponse(currentCharacter, option);
            
            setTimeout(() => {
                currentCharacter.userData.conversations.push({
                    user: option,
                    response: responseText
                });
                
                dialogueContent.innerHTML = dialogueContent.innerHTML.replace(
                    '<span class="loading"></span>',
                    responseText
                );
                
                dialogueContent.scrollTop = dialogueContent.scrollHeight;
                
                if (Math.random() < 0.2) {
                    createFloatingText('üí°', currentCharacter.position);
                }
                
                const newOptions = generateDialogueOptions(currentCharacter);
                dialogueOptions.innerHTML = '';
                
                newOptions.forEach(opt => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'dialogue-option';
                    optionDiv.textContent = opt;
                    optionDiv.onclick = () => selectOption(opt);
                    dialogueOptions.appendChild(optionDiv);
                });
                
                dialogueOptions.style.pointerEvents = 'auto';
                dialogueOptions.style.opacity = '1';
                customQuestionInput.disabled = false;
                customQuestionSubmit.disabled = false;
                customQuestionInput.focus();
            }, 1000 + Math.random() * 2000);
        }
        
        function generateFallbackResponse(character, question) {
            const responses = {
                'Meaty': [
                    "Good question, mate! Coding's like cooking - you need the right ingredients, proper timing, and don't forget to taste-test. Speaking of which, fancy a bacon sandwich?",
                    "That's proper interesting! I code best when I'm well-fed. Nothing beats debugging with a good curry by your side. Food fuels the brain, you know!",
                    "You know what? The best algorithms are like good recipes - simple, efficient, and everyone wants the secret. Pass the biscuits while I explain..."
                ],
                'Scouse': [
                    "Sound question, lad! UX is like managing Liverpool FC - you need to know your users like Klopp knows his players. Every interaction matters!",
                    "That's boss thinking! Design's all about the beautiful game - smooth passes, clean lines, and making sure nobody gets confused in the penalty box.",
                    "Here's the thing, right - good design is like a perfect through-ball. Simple, elegant, and gets you exactly where you need to go. YNWA!"
                ],
                'Simon': [
                    "Statistically speaking, that's an excellent question. I analyzed 1,000 conversations and yours ranks in the 92nd percentile for thoughtfulness.",
                    "Fascinating. The probability of someone asking such an insightful question is approximately 0.23. You're clearly an outlier - in the best way.",
                    "Interesting data point. Did you know that 73.6% of office conversations are about coffee? This one's much more engaging, thankfully."
                ],
                'Tick': [
                    "Yo! That question's got a sick beat to it! Music production is like coding but with more bass drops. Want to hear about my latest techno track? *bounces rhythmically*",
                    "Proper banging question! Everything's got rhythm if you listen close enough - even conversations have BPM. This chat's hitting about 125 beats per minute, perfect for deep house!",
                    "Sound question, mate! I live for the drop, breathe in 4/4 time, and my heart beats in techno. Press SPACE and let's have a dance-off! The office floor is our dancefloor!"
                ]
            };
            
            const characterResponses = responses[character.userData.name] || [
                "That's a thoughtful question! I really enjoy the collaborative aspect of working here.",
                "Great question! Every day brings new challenges and opportunities to learn.",
                "Interesting perspective! I find that the best solutions come from working together as a team."
            ];
            
            return characterResponses[Math.floor(Math.random() * characterResponses.length)];
        }
        
        // Close dialogue with Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                dialogueBox.style.display = 'none';
                currentCharacter = null;
                if (document.pointerLockElement === renderer.domElement) {
                    document.exitPointerLock();
                }
            }
        });
        
        // Custom question handlers
        const customQuestionInput = document.getElementById('custom-question-input');
        const customQuestionSubmit = document.getElementById('custom-question-submit');
        
        customQuestionSubmit.addEventListener('click', () => {
            const customQuestion = customQuestionInput.value.trim();
            if (customQuestion && currentCharacter) {
                selectOption(customQuestion);
                customQuestionInput.value = '';
            }
        });
        
        customQuestionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const customQuestion = customQuestionInput.value.trim();
                if (customQuestion && currentCharacter) {
                    selectOption(customQuestion);
                    customQuestionInput.value = '';
                }
            }
        });
        
        // Animation loop
        let lastTime = 0;
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            // Update lighting animations
            animateLighting();
            
            // Update player movement
            player.velocity.set(0, 0, 0);
            
            if (!player.isDancing && dialogueBox.style.display !== 'block') {
                if (keys['w']) player.velocity.z = player.speed;
                if (keys['s']) player.velocity.z = -player.speed;
                if (keys['a']) player.velocity.x = -player.speed;
                if (keys['d']) player.velocity.x = player.speed;
            }
            
            // Arrow key camera controls
            const lookSpeed = 0.05;
            if (dialogueBox.style.display !== 'block') {
                if (keys['ArrowLeft']) {
                    mouseX += lookSpeed;
                }
                if (keys['ArrowRight']) {
                    mouseX -= lookSpeed;
                }
            }
            
            // Update camera rotation
            if (!player.isDancing && dialogueBox.style.display !== 'block') {
                camera.rotation.y = mouseX;
                camera.rotation.x = 0;
            }
            
            // Apply movement in camera direction
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();
            
            player.position.add(forward.multiplyScalar(player.velocity.z));
            player.position.add(right.multiplyScalar(player.velocity.x));
            
            // Keep player in bounds
            player.position.x = Math.max(-18, Math.min(18, player.position.x));
            player.position.z = Math.max(-18, Math.min(18, player.position.z));
            
            // Dancing animation
            if (player.isDancing && dialogueBox.style.display !== 'block') {
                camera.position.y = player.position.y + Math.sin(Date.now() * 0.01) * 0.2;
                camera.rotation.z = Math.sin(Date.now() * 0.01) * 0.1;
                camera.rotation.y = mouseX;
                camera.rotation.x = 0;
            } else {
                camera.position.copy(player.position);
                camera.rotation.z = 0;
                if (dialogueBox.style.display !== 'block') {
                    camera.rotation.y = mouseX;
                    camera.rotation.x = 0;
                }
            }
            
            // Update character movement
            characters.forEach(character => {
                updateCharacterMovement(character, deltaTime);
                
                if (character.userData.isDancing) {
                    character.rotation.y += 0.1;
                    character.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.3;
                    
                    character.userData.leftArm.rotation.z = Math.sin(Date.now() * 0.01) * 0.5 + Math.PI / 8;
                    character.userData.rightArm.rotation.z = -Math.sin(Date.now() * 0.01) * 0.5 - Math.PI / 8;
                }
            });
            
            // Update Interactive Ball Physics
            const ballData = ball.userData;
            
            // Apply gravity
            ballData.velocity.y += ballData.gravity;
            
            // Apply friction
            ballData.velocity.multiplyScalar(ballData.friction);
            
            // Update position
            ball.position.add(ballData.velocity);
            
            // Ground collision (with some bounce tolerance)
            if (ball.position.y <= ballData.radius) {
                ball.position.y = ballData.radius;
                if (ballData.velocity.y < 0) {
                    ballData.velocity.y = -ballData.velocity.y * ballData.bounce;
                    ballData.isGrounded = true;
                    
                    // Create bounce effect
                    if (Math.abs(ballData.velocity.y) > 0.05) {
                        createFloatingText('Bounce!', ball.position);
                    }
                } else {
                    ballData.isGrounded = true;
                }
            } else {
                ballData.isGrounded = false;
            }
            
            // Wall collisions
            const wallBounce = 18 - ballData.radius;
            if (Math.abs(ball.position.x) > wallBounce) {
                ball.position.x = Math.sign(ball.position.x) * wallBounce;
                ballData.velocity.x = -ballData.velocity.x * ballData.bounce;
                createFloatingText('Bonk!', ball.position);
            }
            if (Math.abs(ball.position.z) > wallBounce) {
                ball.position.z = Math.sign(ball.position.z) * wallBounce;
                ballData.velocity.z = -ballData.velocity.z * ballData.bounce;
                createFloatingText('Smack!', ball.position);
            }
            
            // Player interaction - kick the ball with proper 2D collision detection!
            // Use 2D distance (ignore Y axis) since player is tall and ball is on ground
            const playerPos2D = new THREE.Vector2(player.position.x, player.position.z);
            const ballPos2D = new THREE.Vector2(ball.position.x, ball.position.z);
            const playerBallDistance2D = playerPos2D.distanceTo(ballPos2D);
            
            const playerRadius = 0.5; // Player collision radius
            const combinedRadius = playerRadius + ballData.radius;
            
            // Update kick cooldown
            if (ballData.kickCooldown > 0) {
                ballData.kickCooldown -= deltaTime;
            }
            
            // Check for 2D collision (ignore height difference)
            const isColliding = playerBallDistance2D <= combinedRadius;
            
            if (isColliding && ballData.kickCooldown <= 0) {
                // Calculate kick direction from player center to ball center
                const kickDirection = new THREE.Vector3()
                    .subVectors(ball.position, player.position);
                
                // Only kick if there's a meaningful direction (not standing exactly on top)
                if (kickDirection.length() > 0.1) {
                    kickDirection.normalize();
                    
                    // Calculate kick strength based on player movement
                    const playerMovementSpeed = player.velocity.length();
                    const baseKickStrength = 0.4;
                    const movementBonus = playerMovementSpeed * 2; // More momentum = harder kick
                    const totalKickStrength = baseKickStrength + movementBonus;
                    
                    // Apply kick force
                    ballData.velocity.add(kickDirection.multiplyScalar(totalKickStrength));
                    ballData.velocity.y += 0.15; // Add slight upward component
                    
                    // Set cooldown to prevent spam kicking
                    ballData.kickCooldown = 0.3; // 300ms cooldown
                    
                    // Visual feedback
                    createFloatingText('KICK!', ball.position);
                    
                    // Debug output to console
                    console.log(`ü¶∂ KICK! Distance: ${playerBallDistance2D.toFixed(2)}, Strength: ${totalKickStrength.toFixed(2)}`);
                    
                    // Add screen shake effect for impact feeling
                    if (totalKickStrength > 0.6) {
                        createFloatingText('üí•', ball.position);
                    }
                }
            }
            
            // Add some rotation based on movement
            ball.rotation.x += ballData.velocity.z * 0.1;
            ball.rotation.z -= ballData.velocity.x * 0.1;
            
            // Dynamic visual effects based on speed
            const speed = ballData.velocity.length();
            
            // Adjust glow intensity based on speed
            const glowLight = ball.children[0]; // The point light we added
            if (glowLight) {
                glowLight.intensity = 0.3 + speed * 2;
                glowLight.distance = 3 + speed * 5;
            }
            
            // Adjust material emissive based on speed
            ballMaterial.emissiveIntensity = 0.1 + speed * 0.5;
            
            // Color shift based on speed (red to yellow when fast)
            if (speed > 0.3) {
                ballMaterial.color.setHSL(0.1 - speed * 0.1, 1, 0.5); // Red to yellow
                ballMaterial.emissive.setHSL(0.1 - speed * 0.1, 1, 0.2);
            } else {
                ballMaterial.color.setHex(0xff4444); // Default red
                ballMaterial.emissive.setHex(0x331111);
            }
            
            // Add trail effect for fast movement
            if (speed > 0.4 && Math.random() < 0.3) {
                const trailPos = ball.position.clone();
                trailPos.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                ));
                createFloatingText('‚ú®', trailPos);
            }
            
            // Check for nearby characters
            nearbyCharacter = null;
            let minDistance = Infinity;
            
            characters.forEach(character => {
                const distance = player.position.distanceTo(character.position);
                if (distance < 3 && distance < minDistance) {
                    minDistance = distance;
                    nearbyCharacter = character;
                }
            });
            
            // Show/hide interaction prompt
            if (nearbyCharacter && !currentCharacter) {
                interactionPrompt.style.display = 'block';
                interactionPrompt.textContent = `Press E to talk to ${nearbyCharacter.userData.name}`;
            } else {
                interactionPrompt.style.display = 'none';
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Mouse look
        let mouseX = 0;
        
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === renderer.domElement && dialogueBox.style.display !== 'block') {
                mouseX += e.movementX * 0.002;
            }
        });
        
        // Ball throwing mechanics
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        renderer.domElement.addEventListener('click', (event) => {
            if (!dialogueBox.style.display || dialogueBox.style.display === 'none') {
                // Check if we clicked on the ball first
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(ball);
                
                if (intersects.length > 0) {
                    // Clicked on ball - throw it!
                    const throwDirection = new THREE.Vector3(0, 0, -1);
                    throwDirection.applyQuaternion(camera.quaternion);
                    throwDirection.normalize();
                    
                    // Add throw force
                    const throwStrength = 0.5;
                    ball.userData.velocity.add(throwDirection.multiplyScalar(throwStrength));
                    ball.userData.velocity.y += 0.3; // Add upward arc
                    
                    createFloatingText('THROW!', ball.position);
                } else {
                    // Normal pointer lock request
                    renderer.domElement.requestPointerLock();
                }
            }
        });
        
        animate(0);
        
        console.log('üöÄ 3D Office Simulator loaded successfully!');
        console.log('WASD to move, E to interact, SPACE to dance, ESC to exit dialogues');
        console.log('Ready for Claude Code development!');
    </script>
</body>
</html>
