<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Office Simulator - Local Development</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        #dialogue-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            display: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
        }
        
        #dialogue-box h3 {
            margin: 0 0 10px 0;
            color: #D97356;
        }
        
        #dialogue-content {
            margin: 10px 0;
            line-height: 1.6;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .dialogue-option {
            background: #f0f0f0;
            border: 2px solid #D97356;
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .dialogue-option:hover {
            background: #D97356;
            color: white;
            transform: translateX(5px);
        }
        
        #custom-question-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        #custom-question-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #D97356;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            box-sizing: border-box;
        }
        
        #custom-question-submit {
            background: #D97356;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            margin-top: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        #custom-question-submit:hover {
            background: #c85a3f;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        #custom-question-submit:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(217, 115, 86, 0.3);
            border-radius: 50%;
            border-top-color: #D97356;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .instruction {
            opacity: 0.8;
            font-size: 14px;
            margin-top: 10px;
        }
        
        #interaction-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            font-size: 14px;
        }
        
        .floating-text {
            position: absolute;
            color: #ff0;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 2s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-100px); }
        }

        #dev-notice {
            position: absolute;
            top: 10px;
            right: 20px;
            background: rgba(0, 255, 0, 0.1);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #00ff00;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="dev-notice">
        LOCAL DEV MODE<br>
        Ready for Claude Code!
    </div>
    
    <div id="ui-overlay">
        <h2 id="title">3D Office Simulator</h2>
        <p style="font-size: 20px;" id="subtitle">üß† Interactive Environment</p>
        <p id="move-instruction">Use WASD to move around</p>
        <p id="look-instruction">Arrow keys or mouse to look left/right</p>
        <p id="interact-instruction">Press E to interact</p>
        <p id="dance-instruction">Press SPACE to dance</p>
        <p id="close-instruction">Press ESC to close dialogs/release mouse</p>
        <p id="ball-instruction">Walk into the red ball to kick it</p>
        <p id="throw-instruction">Click on the ball to throw it</p>
        <p class="instruction" style="margin-top: 10px;" id="tip-instruction">üí° Type custom questions when talking!</p>
    </div>
    
    <div id="dialogue-box">
        <h3 id="dialogue-name">Character Name</h3>
        <div id="dialogue-content">Dialogue content will appear here</div>
        <div id="dialogue-options"></div>
        <div id="custom-question-container">
            <p style="margin: 5px 0; font-size: 14px; opacity: 0.8; text-align: center;" id="custom-question-divider">‚îÅ‚îÅ‚îÅ Or ask your own question ‚îÅ‚îÅ‚îÅ</p>
            <input type="text" id="custom-question-input" placeholder="Ask anything! e.g., 'What's your favorite feature?' or 'Tell me about your work'" maxlength="200">
            <button id="custom-question-submit">Ask Question</button>
        </div>
    </div>
    
    <div id="interaction-prompt"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        console.log('üöÄ 3D Office Simulator - Local Development Mode');
        console.log('Ready for customization with Claude Code!');
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);
        scene.fog = new THREE.Fog(0xf5f5f5, 10, 50);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Floating text effect
        function createFloatingText(text, worldPos) {
            const screenPos = worldPos.clone();
            screenPos.project(camera);
            
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
            
            const div = document.createElement('div');
            div.className = 'floating-text';
            div.textContent = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.body.appendChild(div);
            
            setTimeout(() => div.remove(), 2000);
        }
        
        // Enhanced Lighting System
        const ambientLight = new THREE.AmbientLight(0xf0f8ff, 0.4);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Accent lighting
        const accentLight1 = new THREE.PointLight(0x00ff88, 0.6, 15);
        accentLight1.position.set(-15, 8, -15);
        scene.add(accentLight1);
        
        const accentLight2 = new THREE.PointLight(0xff4488, 0.6, 15);
        accentLight2.position.set(15, 8, -15);
        scene.add(accentLight2);
        
        const accentLight3 = new THREE.PointLight(0x4488ff, 0.6, 15);
        accentLight3.position.set(0, 8, 15);
        scene.add(accentLight3);
        
        // Ceiling mood lighting (subtle color changing)
        const moodLight = new THREE.PointLight(0x6366f1, 0.3, 25);
        moodLight.position.set(0, 12, 0);
        scene.add(moodLight);
        
        // Animate mood lighting
        let lightTime = 0;
        function animateLighting() {
            lightTime += 0.01;
            const hue = (Math.sin(lightTime) + 1) * 0.5;
            moodLight.color.setHSL(hue * 0.6 + 0.6, 0.5, 0.3);
        }
        
        // Floor with pattern
        const floorGeometry = new THREE.PlaneGeometry(40, 40);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xdcdcdc,
            roughness: 0.7,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Add floor tiles pattern
        const tileGeometry = new THREE.PlaneGeometry(2, 2);
        const tileMaterial1 = new THREE.MeshStandardMaterial({ color: 0xe8e8e8 });
        const tileMaterial2 = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });
        
        for (let x = -20; x < 20; x += 2) {
            for (let z = -20; z < 20; z += 2) {
                const tile = new THREE.Mesh(tileGeometry, ((x + z) / 2) % 2 === 0 ? tileMaterial1 : tileMaterial2);
                tile.position.set(x + 1, 0.01, z + 1);
                tile.rotation.x = -Math.PI / 2;
                tile.receiveShadow = true;
                scene.add(tile);
            }
        }
        
        // Walls with windows
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xf8f8f8,
            roughness: 0.9
        });
        
        const windowMaterial = new THREE.MeshStandardMaterial({
            color: 0x87ceeb,
            transparent: true,
            opacity: 0.3,
            roughness: 0.1,
            metalness: 0.5
        });
        
        // Back wall with windows
        const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        backWall.position.set(0, 5, -20);
        backWall.receiveShadow = true;
        scene.add(backWall);
        
        // Add windows to back wall
        for (let x = -15; x <= 15; x += 10) {
            const window = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 3),
                windowMaterial
            );
            window.position.set(x, 5, -19.9);
            scene.add(window);
        }
        
        // Side walls
        const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        leftWall.position.set(-20, 5, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        scene.add(leftWall);
        
        const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        rightWall.position.set(20, 5, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        scene.add(rightWall);
        
        // Office furniture materials
        const woodMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b6914,
            roughness: 0.6,
            metalness: 0.1
        });
        
        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0x404040,
            roughness: 0.3,
            metalness: 0.8
        });
        
        // Create detailed desks
        function createDesk(x, z) {
            const deskGroup = new THREE.Group();
            
            // Desk top
            const deskTop = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 1.5),
                woodMaterial
            );
            deskTop.position.y = 0.75;
            deskTop.castShadow = true;
            deskTop.receiveShadow = true;
            deskGroup.add(deskTop);
            
            // Metal frame
            const frameGeometry = new THREE.BoxGeometry(0.05, 0.7, 0.05);
            const framePositions = [
                [-1.45, 0.35, -0.7],
                [1.45, 0.35, -0.7],
                [-1.45, 0.35, 0.7],
                [1.45, 0.35, 0.7]
            ];
            
            framePositions.forEach(pos => {
                const frame = new THREE.Mesh(frameGeometry, metalMaterial);
                frame.position.set(...pos);
                frame.castShadow = true;
                deskGroup.add(frame);
            });
            
            // Computer monitor
            const monitorBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16),
                metalMaterial
            );
            monitorBase.position.set(0, 0.82, 0);
            deskGroup.add(monitorBase);
            
            const monitorStand = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.3, 0.05),
                metalMaterial
            );
            monitorStand.position.set(0, 0.95, 0);
            deskGroup.add(monitorStand);
            
            const monitorScreen = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.7, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.5 })
            );
            monitorScreen.position.set(0, 1.3, 0);
            deskGroup.add(monitorScreen);
            
            // Keyboard
            const keyboard = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.02, 0.15),
                metalMaterial
            );
            keyboard.position.set(0, 0.81, 0.3);
            deskGroup.add(keyboard);
            
            // Chair
            const chairSeat = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.05, 0.5),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairSeat.position.set(0, 0.5, 0.8);
            deskGroup.add(chairSeat);
            
            const chairBack = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.6, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairBack.position.set(0, 0.8, 1.02);
            deskGroup.add(chairBack);
            
            // Random desk items
            if (Math.random() > 0.5) {
                const mug = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 0.1, 8),
                    new THREE.MeshStandardMaterial({ color: 0xffffff })
                );
                mug.position.set(Math.random() * 0.5 - 0.25, 0.85, Math.random() * 0.3);
                deskGroup.add(mug);
            }
            
            // Desk lamp
            const lampBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.05, 8),
                metalMaterial
            );
            lampBase.position.set(-1, 0.82, -0.3);
            deskGroup.add(lampBase);
            
            const lampArm = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.8, 8),
                metalMaterial
            );
            lampArm.position.set(-1, 1.2, -0.3);
            lampArm.rotation.z = Math.PI / 6;
            deskGroup.add(lampArm);
            
            const lampHead = new THREE.Mesh(
                new THREE.ConeGeometry(0.2, 0.3, 8),
                metalMaterial
            );
            lampHead.position.set(-0.7, 1.5, -0.3);
            lampHead.rotation.z = -Math.PI / 3;
            deskGroup.add(lampHead);
            
            // Lamp light
            const lampLight = new THREE.PointLight(0xffd700, 0.8, 5);
            lampLight.position.set(-0.6, 1.4, -0.3);
            lampLight.castShadow = true;
            deskGroup.add(lampLight);
            
            deskGroup.position.set(x, 0, z);
            return deskGroup;
        }
        
        // Add desks
        const desk1 = createDesk(-10, -10);
        const desk2 = createDesk(0, -10);
        const desk3 = createDesk(10, -10);
        const desk4 = createDesk(-10, 5);
        const desk5 = createDesk(0, 5);
        const desk6 = createDesk(10, 5);
        scene.add(desk1, desk2, desk3, desk4, desk5, desk6);
        
        // Add whiteboard
        const whiteboardMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffffff,
            roughness: 0.2,
            metalness: 0.1
        });
        
        const whiteboard = new THREE.Mesh(
            new THREE.BoxGeometry(4, 2, 0.1),
            whiteboardMaterial
        );
        whiteboard.position.set(0, 3, -19.8);
        whiteboard.castShadow = true;
        scene.add(whiteboard);
        
        // Company Logo on back wall
        function createTextTexture(text, bgColor, textColor, fontSize = 48) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            context.fillStyle = bgColor;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = textColor;
            context.font = `bold ${fontSize}px Arial`;
            context.textAlign = 'center';
            context.fillText(text, canvas.width / 2, canvas.height / 2 + fontSize / 4);
            
            return new THREE.CanvasTexture(canvas);
        }
        
        const logoTexture = createTextTexture('TECH SOLUTIONS', '#1e3a8a', '#ffffff', 36);
        const logoMaterial = new THREE.MeshStandardMaterial({ map: logoTexture });
        const logo = new THREE.Mesh(
            new THREE.PlaneGeometry(6, 3),
            logoMaterial
        );
        logo.position.set(0, 6, -19.7);
        scene.add(logo);
        
        // Motivational Posters
        const posterMessages = [
            { text: 'CODE\nCREATE\nINNOVATE', color: '#e11d48' },
            { text: 'THINK\nDIFFERENT', color: '#059669' },
            { text: 'FAIL FAST\nLEARN FASTER', color: '#7c3aed' },
            { text: 'DEPLOY\nON FRIDAY', color: '#dc2626' }
        ];
        
        // Left wall posters
        posterMessages.slice(0, 2).forEach((poster, index) => {
            const posterTexture = createTextTexture(poster.text, '#f8fafc', poster.color, 28);
            const posterMaterial = new THREE.MeshStandardMaterial({ map: posterTexture });
            const posterMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(2.5, 3),
                posterMaterial
            );
            posterMesh.position.set(-19.7, 4 + (index * 3), -8 + (index * 8));
            posterMesh.rotation.y = Math.PI / 2;
            scene.add(posterMesh);
        });
        
        // Right wall posters
        posterMessages.slice(2).forEach((poster, index) => {
            const posterTexture = createTextTexture(poster.text, '#f8fafc', poster.color, 28);
            const posterMaterial = new THREE.MeshStandardMaterial({ map: posterTexture });
            const posterMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(2.5, 3),
                posterMaterial
            );
            posterMesh.position.set(19.7, 4 + (index * 3), -8 + (index * 8));
            posterMesh.rotation.y = -Math.PI / 2;
            scene.add(posterMesh);
        });
        
        // Digital Screens with Content
        function createDigitalScreen(x, y, z, rotation = 0) {
            const screenGroup = new THREE.Group();
            
            // Screen frame
            const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(3.2, 2.2, 0.1),
                frameMaterial
            );
            screenGroup.add(frame);
            
            // Screen content (will animate)
            const screenCanvas = document.createElement('canvas');
            screenCanvas.width = 512;
            screenCanvas.height = 256;
            const screenContext = screenCanvas.getContext('2d');
            
            // Initial screen content
            function updateScreen() {
                const now = Date.now();
                const time = new Date().toLocaleTimeString();
                
                screenContext.fillStyle = '#0f172a';
                screenContext.fillRect(0, 0, 512, 256);
                
                screenContext.fillStyle = '#06b6d4';
                screenContext.font = 'bold 24px Arial';
                screenContext.textAlign = 'center';
                screenContext.fillText('SYSTEM STATUS', 256, 40);
                
                screenContext.fillStyle = '#10b981';
                screenContext.font = '18px Arial';
                screenContext.fillText('‚úì All Systems Online', 256, 80);
                screenContext.fillText('‚úì Deployment Ready', 256, 110);
                screenContext.fillText('‚úì Tests Passing', 256, 140);
                
                screenContext.fillStyle = '#06b6d4';
                screenContext.font = '16px Arial';
                screenContext.fillText(time, 256, 180);
                
                screenContext.fillStyle = '#8b5cf6';
                screenContext.fillText(`Uptime: ${Math.floor(now/1000/60)} min`, 256, 210);
            }
            
            updateScreen();
            const screenTexture = new THREE.CanvasTexture(screenCanvas);
            
            const screen = new THREE.Mesh(
                new THREE.PlaneGeometry(3, 2),
                new THREE.MeshStandardMaterial({ 
                    map: screenTexture,
                    emissive: 0x111111
                })
            );
            screen.position.z = 0.06;
            screenGroup.add(screen);
            
            // Update screen content periodically
            setInterval(() => {
                updateScreen();
                screenTexture.needsUpdate = true;
            }, 1000);
            
            screenGroup.position.set(x, y, z);
            screenGroup.rotation.y = rotation;
            return screenGroup;
        }
        
        // Add digital screens
        const screen1 = createDigitalScreen(-15, 4, -19.8);
        const screen2 = createDigitalScreen(15, 4, -19.8);
        scene.add(screen1, screen2);
        
        // Neon accent elements
        function createNeonSign(text, x, y, z, color) {
            const neonGroup = new THREE.Group();
            
            // Neon tube effect using glowing geometry
            const neonMaterial = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.9
            });
            
            // Background panel
            const panel = new THREE.Mesh(
                new THREE.PlaneGeometry(text.length * 0.5, 1),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    transparent: true,
                    opacity: 0.8
                })
            );
            neonGroup.add(panel);
            
            // Neon text effect (simplified as colored rectangles)
            for (let i = 0; i < text.length; i++) {
                const letter = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.3, 0.6),
                    neonMaterial
                );
                letter.position.x = (i - text.length/2) * 0.4;
                letter.position.z = 0.01;
                neonGroup.add(letter);
            }
            
            // Glow light
            const glowLight = new THREE.PointLight(color, 1, 8);
            glowLight.position.z = 1;
            neonGroup.add(glowLight);
            
            neonGroup.position.set(x, y, z);
            return neonGroup;
        }
        
        // Add neon signs
        const neonExit = createNeonSign('EXIT', 18, 7, 0, 0x00ff00);
        neonExit.rotation.y = -Math.PI / 2;
        scene.add(neonExit);
        
        const neonCafe = createNeonSign('CAFE', -18, 3, 8, 0xff0080);
        neonCafe.rotation.y = Math.PI / 2;
        scene.add(neonCafe);
        
        // Long Corridor Extension
        const corridorLength = 60; // Very long corridor
        const corridorWidth = 6;
        const corridorHeight = 10;
        
        // Create corridor opening in the right wall
        const corridorOpening = new THREE.Mesh(
            new THREE.PlaneGeometry(corridorWidth, corridorHeight),
            new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a, // Darker to show depth
                transparent: true,
                opacity: 0.1
            })
        );
        corridorOpening.position.set(20, 5, 0);
        corridorOpening.rotation.y = -Math.PI / 2;
        scene.add(corridorOpening);
        
        // Corridor floor
        const corridorFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(corridorLength, corridorWidth),
            new THREE.MeshStandardMaterial({ 
                color: 0xc8c8c8,
                roughness: 0.8
            })
        );
        corridorFloor.rotation.x = -Math.PI / 2;
        corridorFloor.position.set(20 + corridorLength/2, 0, 0);
        corridorFloor.receiveShadow = true;
        scene.add(corridorFloor);
        
        // Corridor ceiling
        const corridorCeiling = new THREE.Mesh(
            new THREE.PlaneGeometry(corridorLength, corridorWidth),
            new THREE.MeshStandardMaterial({ 
                color: 0xf0f0f0,
                roughness: 0.9
            })
        );
        corridorCeiling.rotation.x = Math.PI / 2;
        corridorCeiling.position.set(20 + corridorLength/2, corridorHeight, 0);
        scene.add(corridorCeiling);
        
        // Corridor walls
        const corridorLeftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(corridorLength, corridorHeight),
            wallMaterial
        );
        corridorLeftWall.position.set(20 + corridorLength/2, 5, -corridorWidth/2);
        corridorLeftWall.receiveShadow = true;
        scene.add(corridorLeftWall);
        
        const corridorRightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(corridorLength, corridorHeight),
            wallMaterial
        );
        corridorRightWall.position.set(20 + corridorLength/2, 5, corridorWidth/2);
        corridorRightWall.rotation.y = Math.PI;
        corridorRightWall.receiveShadow = true;
        scene.add(corridorRightWall);
        
        // End wall of corridor
        const corridorEndWall = new THREE.Mesh(
            new THREE.PlaneGeometry(corridorWidth, corridorHeight),
            wallMaterial
        );
        corridorEndWall.position.set(20 + corridorLength, 5, 0);
        corridorEndWall.rotation.y = Math.PI / 2;
        scene.add(corridorEndWall);
        
        // Create multiple doors along the corridor
        function createDoor(x, z, rotation, label) {
            const doorGroup = new THREE.Group();
            
            // Door frame
            const doorFrameMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const doorFrame = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 7, 0.2),
                doorFrameMaterial
            );
            doorGroup.add(doorFrame);
            
            // Door panel
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.7 
            });
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(2, 6.5, 0.15),
                doorMaterial
            );
            door.position.y = 0.25;
            door.position.z = 0.05;
            doorGroup.add(door);
            
            // Door handle
            const handleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                metalness: 0.8,
                roughness: 0.2
            });
            const handle = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 8, 8),
                handleMaterial
            );
            handle.position.set(0.7, 0, 0.1);
            doorGroup.add(handle);
            
            // Door number/label
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.fillRect(0, 0, 128, 64);
            context.fillStyle = 'black';
            context.font = 'bold 20px Arial';
            context.textAlign = 'center';
            context.fillText(label, 64, 40);
            
            const labelTexture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.MeshStandardMaterial({ map: labelTexture });
            const labelPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(0.8, 0.4),
                labelMaterial
            );
            labelPlane.position.set(0, 2, 0.16);
            doorGroup.add(labelPlane);
            
            doorGroup.position.set(x, 3.5, z);
            doorGroup.rotation.y = rotation;
            return doorGroup;
        }
        
        // Add doors along the left wall of corridor
        const doorSpacing = 8;
        for (let i = 0; i < 6; i++) {
            const doorX = 25 + (i * doorSpacing);
            const leftDoor = createDoor(doorX, -2.9, 0, `${101 + i}`);
            scene.add(leftDoor);
        }
        
        // Add doors along the right wall of corridor  
        for (let i = 0; i < 6; i++) {
            const doorX = 27 + (i * doorSpacing);
            const rightDoor = createDoor(doorX, 2.9, Math.PI, `${201 + i}`);
            scene.add(rightDoor);
        }
        
        // Corridor lighting
        const corridorLights = [];
        for (let i = 0; i < 8; i++) {
            const lightX = 25 + (i * 7);
            const corridorLight = new THREE.PointLight(0xffffff, 0.6, 12);
            corridorLight.position.set(lightX, 8, 0);
            corridorLight.castShadow = true;
            scene.add(corridorLight);
            corridorLights.push(corridorLight);
        }
        
        // Emergency lighting for atmosphere
        const emergencyLight = new THREE.PointLight(0xff4444, 0.3, 15);
        emergencyLight.position.set(20 + corridorLength - 5, 8, 0);
        scene.add(emergencyLight);
        
        // Interactive Bouncing Ball
        const ballGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const ballMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xff4444,
            roughness: 0.4,
            metalness: 0.1,
            transparent: true,
            opacity: 0.9,
            emissive: 0x331111,
            emissiveIntensity: 0.2
        });
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(5, 2, 5); // Start higher for bouncing
        ball.castShadow = true;
        ball.receiveShadow = true;
        
        // Add glow effect
        const ballGlow = new THREE.PointLight(0xff4444, 0.5, 5);
        ball.add(ballGlow);
        
        // Physics properties
        ball.userData = {
            velocity: new THREE.Vector3(0.1, 0, 0.08),
            gravity: -0.015,
            bounce: 0.8, // Energy retained after bounce
            friction: 0.98, // Air/ground friction
            radius: 0.3,
            isGrounded: false,
            recentlyKicked: false, // Prevent spam kicking
            kickCooldown: 0
        };
        scene.add(ball);
        
        // Plant decorations
        const plantPot = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.25, 0.4, 8),
            new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        plantPot.position.set(-15, 0.2, -15);
        scene.add(plantPot);
        
        const plantLeaves = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 6, 5),
            new THREE.MeshStandardMaterial({ color: 0x228b22 })
        );
        plantLeaves.position.set(-15, 0.8, -15);
        scene.add(plantLeaves);
        
        // Add more plants
        const plantPot2 = plantPot.clone();
        plantPot2.position.set(15, 0.2, -15);
        scene.add(plantPot2);
        
        const plantLeaves2 = plantLeaves.clone();
        plantLeaves2.position.set(15, 0.8, -15);
        scene.add(plantLeaves2);
        
        const plantPot3 = plantPot.clone();
        plantPot3.position.set(0, 0.2, 15);
        scene.add(plantPot3);
        
        const plantLeaves3 = plantLeaves.clone();
        plantLeaves3.position.set(0, 0.8, 15);
        scene.add(plantLeaves3);
        
        // Add coffee station
        const coffeeTable = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.8, 1),
            woodMaterial
        );
        coffeeTable.position.set(-18, 0.4, 10);
        coffeeTable.castShadow = true;
        scene.add(coffeeTable);
        
        const coffeeMachine = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 0.5, 0.3),
            metalMaterial
        );
        coffeeMachine.position.set(-18, 1.05, 10);
        scene.add(coffeeMachine);
        
        // Character creation
        const characters = [];
        
        function createCharacter(name, role, x, z, shirtColor, characterData) {
            const group = new THREE.Group();
            
            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.8, 8);
            const torsoMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.y = 0.6;
            torso.castShadow = true;
            group.add(torso);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6);
            const armMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.3, 0.7, 0);
            leftArm.rotation.z = Math.PI / 8;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.3, 0.7, 0);
            rightArm.rotation.z = -Math.PI / 8;
            group.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.4, 0);
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.4, 0);
            group.add(rightLeg);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 8, 6);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.25;
            head.castShadow = true;
            group.add(head);
            
            // Hair
            const hairGeometry = new THREE.SphereGeometry(0.27, 8, 6);
            const hairMaterial = new THREE.MeshStandardMaterial({ color: characterData.hairColor });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.35;
            hair.scale.y = 0.6;
            group.add(hair);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.03, 4, 4);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.25, 0.22);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.25, 0.22);
            group.add(rightEye);
            
            // Name label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillRect(0, 0, 256, 64);
            context.fillStyle = 'black';
            context.font = 'bold 20px Arial';
            context.textAlign = 'center';
            context.fillText(name, 128, 25);
            context.font = '16px Arial';
            context.fillStyle = '#666';
            context.fillText(role, 128, 45);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.y = 1.8;
            label.scale.set(2, 0.5, 1);
            group.add(label);
            
            group.position.set(x, 0, z);
            group.userData = { 
                name, 
                role, 
                conversations: [],
                initialPosition: new THREE.Vector3(x, 0, z),
                targetPosition: new THREE.Vector3(x, 0, z),
                moveTimer: 0,
                isDancing: false,
                tripChance: 0.001,
                leftArm: leftArm,
                rightArm: rightArm,
                ...characterData
            };
            
            characters.push(group);
            return group;
        }
        
        // Add sample characters (you can customize these!)
        const character1 = createCharacter('Alex Chen', 'Lead Developer', -10, -5, 0x4169e1, {
            hairColor: 0x3d3d3d,
            personality: 'thoughtful and innovative',
            quirk: 'explains everything with code analogies'
        });
        
        const character2 = createCharacter('Sarah Kim', 'UX Designer', 10, -5, 0x9370db, {
            hairColor: 0x4b0082,
            personality: 'creative and user-focused',
            quirk: 'sees the world as wireframes'
        });
        
        const character3 = createCharacter('Mike Torres', 'Data Scientist', -10, 5, 0x228b22, {
            hairColor: 0x8b4513,
            personality: 'analytical and precise',
            quirk: 'gets excited about correlation coefficients'
        });
        
        const character4 = createCharacter('Jamie Liu', 'Product Manager', 10, 5, 0xffa500, {
            hairColor: 0x8b4513,
            personality: 'strategic and collaborative',
            quirk: 'organizes everything into sprints'
        });
        
        scene.add(character1, character2, character3, character4);
        
        // Player controls
        const player = {
            position: new THREE.Vector3(0, 1.6, 5),
            velocity: new THREE.Vector3(0, 0, 0),
            speed: 0.1,
            isDancing: false
        };
        
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            const customQuestionInput = document.getElementById('custom-question-input');
            
            if (document.activeElement === customQuestionInput) {
                if (e.key === 'Escape') {
                    dialogueBox.style.display = 'none';
                    currentCharacter = null;
                    if (document.pointerLockElement === renderer.domElement) {
                        document.exitPointerLock();
                    }
                }
                return;
            }
            
            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
            
            if (e.key.toLowerCase() === 'e' && nearbyCharacter && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                openDialogue(nearbyCharacter);
            }
            
            if (e.key === ' ' && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                player.isDancing = true;
                createFloatingText('üíÉüï∫', player.position);
            }
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const customQuestionInput = document.getElementById('custom-question-input');
            
            if (document.activeElement === customQuestionInput) {
                return;
            }
            
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
            
            if (e.key === ' ' && dialogueBox.style.display !== 'block') {
                player.isDancing = false;
            }
        });
        
        // Character movement AI
        function updateCharacterMovement(character, deltaTime) {
            if (Math.random() < character.userData.tripChance && !character.userData.isDancing) {
                character.rotation.x = Math.PI / 4;
                character.position.y = 0.3;
                createFloatingText('Oof!', character.position);
                
                setTimeout(() => {
                    character.userData.tripChance = 0.001;
                }, 5000);
            }
            
            if (character === currentCharacter || character.userData.isDancing) {
                if (character === currentCharacter) {
                    const lookTarget = new THREE.Vector3(player.position.x, character.position.y, player.position.z);
                    character.lookAt(lookTarget);
                    character.rotation.x = 0;
                    character.rotation.z = 0;
                }
                return;
            }
            
            if (Math.random() < 0.001) {
                character.userData.isDancing = true;
                createFloatingText('üéµ', character.position);
                setTimeout(() => {
                    character.userData.isDancing = false;
                }, 3000);
            }
            
            character.userData.moveTimer -= deltaTime;
            
            if (character.userData.moveTimer <= 0) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 3 + Math.random() * 5;
                character.userData.targetPosition = new THREE.Vector3(
                    character.userData.initialPosition.x + Math.cos(angle) * distance,
                    0,
                    character.userData.initialPosition.z + Math.sin(angle) * distance
                );
                
                character.userData.targetPosition.x = Math.max(-18, Math.min(18, character.userData.targetPosition.x));
                character.userData.targetPosition.z = Math.max(-18, Math.min(18, character.userData.targetPosition.z));
                
                character.userData.moveTimer = 5 + Math.random() * 5;
            }
            
            const direction = new THREE.Vector3().subVectors(character.userData.targetPosition, character.position);
            direction.y = 0;
            const distance = direction.length();
            
            if (distance > 0.1) {
                direction.normalize();
                character.position.add(direction.multiplyScalar(0.02));
                
                character.lookAt(character.userData.targetPosition);
                character.rotation.x = 0;
                character.rotation.z = 0;
                
                if (!character.userData.isDancing) {
                    character.position.y = Math.abs(Math.sin(Date.now() * 0.005)) * 0.05;
                }
            }
        }
        
        // Dialogue system
        const dialogueBox = document.getElementById('dialogue-box');
        const dialogueName = document.getElementById('dialogue-name');
        const dialogueContent = document.getElementById('dialogue-content');
        const dialogueOptions = document.getElementById('dialogue-options');
        const interactionPrompt = document.getElementById('interaction-prompt');
        
        let currentCharacter = null;
        let nearbyCharacter = null;
        
        function generateDialogueOptions(character) {
            const questions = [
                "Tell me about your role here",
                "What's a typical day like for you?",
                "What's the most challenging part of your job?",
                "What project are you most excited about?",
                "What's your favorite development tool?",
                "Any advice for someone starting out?",
                "What's the weirdest bug you've encountered?",
                "Coffee or tea?",
                "Tabs or spaces?",
                "What's your git commit style?"
            ];
            
            const shuffled = questions.sort(() => Math.random() - 0.5);
            return shuffled.slice(0, 4);
        }
        
        function openDialogue(character) {
            currentCharacter = character;
            dialogueBox.style.display = 'block';
            dialogueName.textContent = `${character.userData.name} - ${character.userData.role}`;
            
            if (document.pointerLockElement === renderer.domElement) {
                document.exitPointerLock();
            }
            
            const greetings = [
                `Hello! I'm ${character.userData.name}, ${character.userData.role}. Ask me anything!`,
                `Hey there! I'm ${character.userData.name}. Just ${character.userData.quirk}, as usual.`,
                `Hi! ${character.userData.name} here. What can I help you understand about our work?`,
                `Great to meet you! I'm ${character.userData.name}. Fair warning: I ${character.userData.quirk}.`
            ];
            
            if (character.userData.conversations.length === 0) {
                dialogueContent.innerHTML = `<p><strong>${character.userData.name}:</strong> ${greetings[Math.floor(Math.random() * greetings.length)]}</p>`;
            } else {
                const lastConv = character.userData.conversations[character.userData.conversations.length - 1];
                dialogueContent.innerHTML = `<p><strong>You:</strong> ${lastConv.user}</p><p><strong>${character.userData.name}:</strong> ${lastConv.response}</p>`;
            }
            
            const options = generateDialogueOptions(character);
            dialogueOptions.innerHTML = '';
            
            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'dialogue-option';
                optionDiv.textContent = option;
                optionDiv.onclick = () => selectOption(option);
                dialogueOptions.appendChild(optionDiv);
            });
            
            document.getElementById('custom-question-input').value = '';
            
            setTimeout(() => {
                document.getElementById('custom-question-input').focus();
            }, 100);
        }
        
        function selectOption(option) {
            if (!currentCharacter) return;
            
            dialogueContent.innerHTML += `<p><strong>You:</strong> ${option}</p>`;
            dialogueContent.innerHTML += `<p><strong>${currentCharacter.userData.name}:</strong> <span class="loading"></span></p>`;
            
            dialogueContent.scrollTop = dialogueContent.scrollHeight;
            
            const customQuestionInput = document.getElementById('custom-question-input');
            const customQuestionSubmit = document.getElementById('custom-question-submit');
            
            dialogueOptions.style.pointerEvents = 'none';
            dialogueOptions.style.opacity = '0.5';
            customQuestionInput.disabled = true;
            customQuestionSubmit.disabled = true;
            
            // Simple fallback responses (replace with your AI integration)
            let responseText = generateFallbackResponse(currentCharacter, option);
            
            setTimeout(() => {
                currentCharacter.userData.conversations.push({
                    user: option,
                    response: responseText
                });
                
                dialogueContent.innerHTML = dialogueContent.innerHTML.replace(
                    '<span class="loading"></span>',
                    responseText
                );
                
                dialogueContent.scrollTop = dialogueContent.scrollHeight;
                
                if (Math.random() < 0.2) {
                    createFloatingText('üí°', currentCharacter.position);
                }
                
                const newOptions = generateDialogueOptions(currentCharacter);
                dialogueOptions.innerHTML = '';
                
                newOptions.forEach(opt => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'dialogue-option';
                    optionDiv.textContent = opt;
                    optionDiv.onclick = () => selectOption(opt);
                    dialogueOptions.appendChild(optionDiv);
                });
                
                dialogueOptions.style.pointerEvents = 'auto';
                dialogueOptions.style.opacity = '1';
                customQuestionInput.disabled = false;
                customQuestionSubmit.disabled = false;
                customQuestionInput.focus();
            }, 1000 + Math.random() * 2000);
        }
        
        function generateFallbackResponse(character, question) {
            const responses = {
                'Alex Chen': [
                    "That's a great question! As lead developer, I focus on architecture and code quality. Think of it like building a skyscraper - you need a solid foundation.",
                    "Interesting! I always approach problems systematically. First, I write a test that fails, then make it pass. It's like debugging life itself!",
                    "You know, the best code is like poetry - elegant, concise, and impossible to understand six months later. Just kidding about that last part!"
                ],
                'Sarah Kim': [
                    "Great question! UX design is all about empathy. I spend my day thinking like our users - sometimes I even dream in wireframes!",
                    "That's fascinating! Every pixel has a purpose. I see the world as one big user interface waiting to be optimized.",
                    "You know what's funny? I organize my grocery list by user journey. Produce ‚Üí Dairy ‚Üí Checkout. It's more efficient that way!"
                ],
                'Mike Torres': [
                    "Excellent question! Data science is like detective work, but instead of fingerprints, I follow correlation coefficients and p-values.",
                    "That's a statistically significant question! I love finding patterns in chaos. Data doesn't lie, but it sure knows how to whisper.",
                    "Fun fact: I once got excited about a 0.97 R-squared value at a dinner party. The correlation between that and awkward silence was perfect."
                ],
                'Jamie Liu': [
                    "Strategic question! As a PM, I think in sprints and user stories. This conversation would be: 'As a visitor, I want to chat with Jamie so I can learn about product management.'",
                    "That's roadmap-worthy thinking! I love connecting user needs with business goals. It's like being a translator between engineers and humans.",
                    "Here's a PM secret: everything is a two-week sprint if you believe hard enough. Even cooking dinner can be agile!"
                ]
            };
            
            const characterResponses = responses[character.userData.name] || [
                "That's a thoughtful question! I really enjoy the collaborative aspect of working here.",
                "Great question! Every day brings new challenges and opportunities to learn.",
                "Interesting perspective! I find that the best solutions come from working together as a team."
            ];
            
            return characterResponses[Math.floor(Math.random() * characterResponses.length)];
        }
        
        // Close dialogue with Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                dialogueBox.style.display = 'none';
                currentCharacter = null;
                if (document.pointerLockElement === renderer.domElement) {
                    document.exitPointerLock();
                }
            }
        });
        
        // Custom question handlers
        const customQuestionInput = document.getElementById('custom-question-input');
        const customQuestionSubmit = document.getElementById('custom-question-submit');
        
        customQuestionSubmit.addEventListener('click', () => {
            const customQuestion = customQuestionInput.value.trim();
            if (customQuestion && currentCharacter) {
                selectOption(customQuestion);
                customQuestionInput.value = '';
            }
        });
        
        customQuestionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const customQuestion = customQuestionInput.value.trim();
                if (customQuestion && currentCharacter) {
                    selectOption(customQuestion);
                    customQuestionInput.value = '';
                }
            }
        });
        
        // Animation loop
        let lastTime = 0;
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            // Update lighting animations
            animateLighting();
            
            // Update player movement
            player.velocity.set(0, 0, 0);
            
            if (!player.isDancing && dialogueBox.style.display !== 'block') {
                if (keys['w']) player.velocity.z = player.speed;
                if (keys['s']) player.velocity.z = -player.speed;
                if (keys['a']) player.velocity.x = -player.speed;
                if (keys['d']) player.velocity.x = player.speed;
            }
            
            // Arrow key camera controls
            const lookSpeed = 0.05;
            if (dialogueBox.style.display !== 'block') {
                if (keys['ArrowLeft']) {
                    mouseX += lookSpeed;
                }
                if (keys['ArrowRight']) {
                    mouseX -= lookSpeed;
                }
            }
            
            // Update camera rotation
            if (!player.isDancing && dialogueBox.style.display !== 'block') {
                camera.rotation.y = mouseX;
                camera.rotation.x = 0;
            }
            
            // Apply movement in camera direction
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();
            
            player.position.add(forward.multiplyScalar(player.velocity.z));
            player.position.add(right.multiplyScalar(player.velocity.x));
            
            // Keep player in bounds (extended for corridor)
            player.position.x = Math.max(-18, Math.min(78, player.position.x)); // Extended to end of corridor
            player.position.z = Math.max(-18, Math.min(18, player.position.z));
            
            // Dancing animation
            if (player.isDancing && dialogueBox.style.display !== 'block') {
                camera.position.y = player.position.y + Math.sin(Date.now() * 0.01) * 0.2;
                camera.rotation.z = Math.sin(Date.now() * 0.01) * 0.1;
                camera.rotation.y = mouseX;
                camera.rotation.x = 0;
            } else {
                camera.position.copy(player.position);
                camera.rotation.z = 0;
                if (dialogueBox.style.display !== 'block') {
                    camera.rotation.y = mouseX;
                    camera.rotation.x = 0;
                }
            }
            
            // Update character movement
            characters.forEach(character => {
                updateCharacterMovement(character, deltaTime);
                
                if (character.userData.isDancing) {
                    character.rotation.y += 0.1;
                    character.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.3;
                    
                    character.userData.leftArm.rotation.z = Math.sin(Date.now() * 0.01) * 0.5 + Math.PI / 8;
                    character.userData.rightArm.rotation.z = -Math.sin(Date.now() * 0.01) * 0.5 - Math.PI / 8;
                }
            });
            
            // Update Interactive Ball Physics
            const ballData = ball.userData;
            
            // Apply gravity
            ballData.velocity.y += ballData.gravity;
            
            // Apply friction
            ballData.velocity.multiplyScalar(ballData.friction);
            
            // Update position
            ball.position.add(ballData.velocity);
            
            // Ground collision (with some bounce tolerance)
            if (ball.position.y <= ballData.radius) {
                ball.position.y = ballData.radius;
                if (ballData.velocity.y < 0) {
                    ballData.velocity.y = -ballData.velocity.y * ballData.bounce;
                    ballData.isGrounded = true;
                    
                    // Create bounce effect
                    if (Math.abs(ballData.velocity.y) > 0.05) {
                        createFloatingText('Bounce!', ball.position);
                    }
                } else {
                    ballData.isGrounded = true;
                }
            } else {
                ballData.isGrounded = false;
            }
            
            // Wall collisions
            const wallBounce = 18 - ballData.radius;
            if (Math.abs(ball.position.x) > wallBounce) {
                ball.position.x = Math.sign(ball.position.x) * wallBounce;
                ballData.velocity.x = -ballData.velocity.x * ballData.bounce;
                createFloatingText('Bonk!', ball.position);
            }
            if (Math.abs(ball.position.z) > wallBounce) {
                ball.position.z = Math.sign(ball.position.z) * wallBounce;
                ballData.velocity.z = -ballData.velocity.z * ballData.bounce;
                createFloatingText('Smack!', ball.position);
            }
            
            // Player interaction - kick the ball with proper 2D collision detection!
            // Use 2D distance (ignore Y axis) since player is tall and ball is on ground
            const playerPos2D = new THREE.Vector2(player.position.x, player.position.z);
            const ballPos2D = new THREE.Vector2(ball.position.x, ball.position.z);
            const playerBallDistance2D = playerPos2D.distanceTo(ballPos2D);
            
            const playerRadius = 0.5; // Player collision radius
            const combinedRadius = playerRadius + ballData.radius;
            
            // Update kick cooldown
            if (ballData.kickCooldown > 0) {
                ballData.kickCooldown -= deltaTime;
            }
            
            // Check for 2D collision (ignore height difference)
            const isColliding = playerBallDistance2D <= combinedRadius;
            
            if (isColliding && ballData.kickCooldown <= 0) {
                // Calculate kick direction from player center to ball center
                const kickDirection = new THREE.Vector3()
                    .subVectors(ball.position, player.position);
                
                // Only kick if there's a meaningful direction (not standing exactly on top)
                if (kickDirection.length() > 0.1) {
                    kickDirection.normalize();
                    
                    // Calculate kick strength based on player movement
                    const playerMovementSpeed = player.velocity.length();
                    const baseKickStrength = 0.4;
                    const movementBonus = playerMovementSpeed * 2; // More momentum = harder kick
                    const totalKickStrength = baseKickStrength + movementBonus;
                    
                    // Apply kick force
                    ballData.velocity.add(kickDirection.multiplyScalar(totalKickStrength));
                    ballData.velocity.y += 0.15; // Add slight upward component
                    
                    // Set cooldown to prevent spam kicking
                    ballData.kickCooldown = 0.3; // 300ms cooldown
                    
                    // Visual feedback
                    createFloatingText('KICK!', ball.position);
                    
                    // Debug output to console
                    console.log(`ü¶∂ KICK! Distance: ${playerBallDistance2D.toFixed(2)}, Strength: ${totalKickStrength.toFixed(2)}`);
                    
                    // Add screen shake effect for impact feeling
                    if (totalKickStrength > 0.6) {
                        createFloatingText('üí•', ball.position);
                    }
                }
            }
            
            // Add some rotation based on movement
            ball.rotation.x += ballData.velocity.z * 0.1;
            ball.rotation.z -= ballData.velocity.x * 0.1;
            
            // Dynamic visual effects based on speed
            const speed = ballData.velocity.length();
            
            // Adjust glow intensity based on speed
            const glowLight = ball.children[0]; // The point light we added
            if (glowLight) {
                glowLight.intensity = 0.3 + speed * 2;
                glowLight.distance = 3 + speed * 5;
            }
            
            // Adjust material emissive based on speed
            ballMaterial.emissiveIntensity = 0.1 + speed * 0.5;
            
            // Color shift based on speed (red to yellow when fast)
            if (speed > 0.3) {
                ballMaterial.color.setHSL(0.1 - speed * 0.1, 1, 0.5); // Red to yellow
                ballMaterial.emissive.setHSL(0.1 - speed * 0.1, 1, 0.2);
            } else {
                ballMaterial.color.setHex(0xff4444); // Default red
                ballMaterial.emissive.setHex(0x331111);
            }
            
            // Add trail effect for fast movement
            if (speed > 0.4 && Math.random() < 0.3) {
                const trailPos = ball.position.clone();
                trailPos.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                ));
                createFloatingText('‚ú®', trailPos);
            }
            
            // Check for nearby characters
            nearbyCharacter = null;
            let minDistance = Infinity;
            
            characters.forEach(character => {
                const distance = player.position.distanceTo(character.position);
                if (distance < 3 && distance < minDistance) {
                    minDistance = distance;
                    nearbyCharacter = character;
                }
            });
            
            // Show/hide interaction prompt
            if (nearbyCharacter && !currentCharacter) {
                interactionPrompt.style.display = 'block';
                interactionPrompt.textContent = `Press E to talk to ${nearbyCharacter.userData.name}`;
            } else {
                interactionPrompt.style.display = 'none';
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Mouse look
        let mouseX = 0;
        
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === renderer.domElement && dialogueBox.style.display !== 'block') {
                mouseX += e.movementX * 0.002;
            }
        });
        
        // Ball throwing mechanics
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        renderer.domElement.addEventListener('click', (event) => {
            if (!dialogueBox.style.display || dialogueBox.style.display === 'none') {
                // Check if we clicked on the ball first
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(ball);
                
                if (intersects.length > 0) {
                    // Clicked on ball - throw it!
                    const throwDirection = new THREE.Vector3(0, 0, -1);
                    throwDirection.applyQuaternion(camera.quaternion);
                    throwDirection.normalize();
                    
                    // Add throw force
                    const throwStrength = 0.5;
                    ball.userData.velocity.add(throwDirection.multiplyScalar(throwStrength));
                    ball.userData.velocity.y += 0.3; // Add upward arc
                    
                    createFloatingText('THROW!', ball.position);
                } else {
                    // Normal pointer lock request
                    renderer.domElement.requestPointerLock();
                }
            }
        });
        
        animate(0);
        
        console.log('üöÄ 3D Office Simulator loaded successfully!');
        console.log('WASD to move, E to interact, SPACE to dance, ESC to exit dialogues');
        console.log('Ready for Claude Code development!');
    </script>
</body>
</html>.rotation.x = 0;
                    character.position.y = 0;
                }, 1000);
                
                character.userData.tripChance = 0;
                setTimeout(() => {
                    character